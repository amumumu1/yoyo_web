<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>ã‚¢ãƒ³ã‚±ãƒ¼ãƒˆé›†è¨ˆçµæœ</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      padding: 20px;
      text-align: center;
      overflow-x: hidden;
    }
    table {
      margin: 10px auto;
      border-collapse: collapse;
      font-size: 18px;
    }
    th, td {
      border: 1px solid #ccc;
      padding: 6px 10px;
      text-align: left;
    }
    h2 {
      margin-top: 40px;
    }
    canvas {
      margin: 30px auto;
      width: 1000px;
      height: 500px;
      display: block;
      border: 1px solid #ddd;
      border-radius: 8px;
      box-shadow: 0 0 6px rgba(0,0,0,0.1);
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
  <h1>ã‚¢ãƒ³ã‚±ãƒ¼ãƒˆé›†è¨ˆçµæœ</h1>
  <a href="viewer.html" class="button">å±¥æ­´ä¸€è¦§ã«æˆ»ã‚‹</a>

  <br><h1>äº‹å‰ã‚¢ãƒ³ã‚±ãƒ¼ãƒˆ</h1>
  <h2>å¹´é½¢åˆ†å¸ƒ</h2>
  <canvas id="ageChart"></canvas>

  <h2>1.ãƒ¨ãƒ¼ãƒ¨ãƒ¼æ­´(ã©ã®ãã‚‰ã„ç¶šã‘ã¦ã„ã¾ã™ã‹ï¼Ÿ)</h2>
  <canvas id="historyChart"></canvas> 

  <h2>2.ãƒ¨ãƒ¼ãƒ¨ãƒ¼ã‚’ã™ã‚‹é »åº¦ã¯ã©ã®ãã‚‰ã„ã§ã™ã‹ï¼Ÿ</h2>
  <canvas id="freqChart"></canvas> 

  <h2>3.æ™®æ®µã©ã®ã‚ˆã†ã«ãƒ¨ãƒ¼ãƒ¨ãƒ¼ã‚’ç·´ç¿’ã—ã¦ã„ã¾ã™ã‹ï¼Ÿï¼ˆè¤‡æ•°å›ç­”å¯ï¼‰</h2>
  <canvas id="practiceChart"></canvas>


  <h2>4.ç·´ç¿’ã™ã‚‹ã¨ãã«å›°ã£ã¦ã„ã‚‹ã“ã¨ã¯ã‚ã‚Šã¾ã™ã‹ï¼Ÿï¼ˆè¤‡æ•°å›ç­”å¯ï¼‰</h2>
  <canvas id="troubleChart"></canvas>

  <h2>5.ãƒ¨ãƒ¼ãƒ¨ãƒ¼ãŒã©ã®ãã‚‰ã„å¾—æ„ã§ã™ã‹ï¼Ÿï¼ˆ0 = ä¸å¾—æ„ / 5 = å¾—æ„ï¼‰</h2>
  <canvas id="skillDistributionChart"></canvas>

  <br><h1>äº‹å¾Œã‚¢ãƒ³ã‚±ãƒ¼ãƒˆ</h1>
  <br><h1>æŒ‡è¼ªå‹ã‚»ãƒ³ã‚·ãƒ³ã‚°ãƒ‡ãƒã‚¤ã‚¹ã«ã¤ã„ã¦</h1>
  <h2>1.ãƒ‡ãƒã‚¤ã‚¹ã‚’ã¤ã‘ã¦ãƒ¨ãƒ¼ãƒ¨ãƒ¼ã‚’ã™ã‚‹ã“ã¨ã«é•å’Œæ„Ÿã¯ã‚ã‚Šã¾ã—ãŸã‹ï¼Ÿ</h2>
  <canvas id="discomfortChart"></canvas>

  <h2>2.ãƒ‡ãƒã‚¤ã‚¹ã®é‡ã•ã‚„å¤§ãã•ã€è£…ç€æ€§ã¯æ°—ã«ãªã‚Šã¾ã—ãŸã‹ï¼Ÿ</h2>
  <canvas id="weightfitChart"></canvas>

  <br><h1>æŠ€èƒ½è©•ä¾¡ã‚·ã‚¹ãƒ†ãƒ ã«ã¤ã„ã¦</h1>
  <h2>4.è©•ä¾¡çµæœã®è¡¨ç¤ºï¼ˆä¾‹ï¼šã‚°ãƒ©ãƒ•ã€è©•ä¾¡ãªã©ï¼‰ã¯ã‚ã‹ã‚Šã‚„ã™ã‹ã£ãŸã§ã™ã‹ï¼Ÿ</h2>
  <canvas id="resultviewChart"></canvas>

  <h2>5.è©•ä¾¡çµæœï¼ˆã§ãã¦ã„ã‚‹ç‚¹ãƒ»ã§ãã¦ã„ãªã„ç‚¹ãªã©ï¼‰ã¯ã€ä»Šå¾Œã®ç·´ç¿’ã®å‚è€ƒã«ãªã‚‹ã¨æ€ã„ã¾ã™ã‹ï¼Ÿ</h2>
  <canvas id="usefulChart"></canvas>


  <h2>6.ã“ã®ã‚·ã‚¹ãƒ†ãƒ ã‚’ä½¿ã£ã¦ã€ä»Šå¾Œã‚‚ç·´ç¿’ã—ãŸã„ã¨æ€ã„ã¾ã—ãŸã‹ï¼Ÿ</h2>
  <canvas id="continueChart"></canvas>

  <h2>7.ä»Šå¾Œã€ã“ã®ã‚·ã‚¹ãƒ†ãƒ ã§åˆ†æã—ã¦ã»ã—ã„ãƒˆãƒªãƒƒã‚¯ã¯ã‚ã‚Šã¾ã™ã‹ï¼Ÿ</h2>
  <canvas id="futureTrickChart"></canvas>




  <br><h1>ãŠã¾ã‘</h1>

  <h1>ç‚¹æ•°</h1>
  <div id="scoreSummary"></div>

  <h2>ãƒ¨ãƒ¼ãƒ¨ãƒ¼æ­´ã¨ã‚¹ã‚³ã‚¢ã®é–¢ä¿‚</h2>
  <canvas id="historyScoreChart"></canvas>

  <h2>å¾—æ„ä¸å¾—æ„ã¨ã‚¹ã‚³ã‚¢ã®é–¢ä¿‚</h2>
  <canvas id="skillScoreChart"></canvas>

  <h2>å¾—æ„ä¸å¾—æ„ã¨ãƒ—ãƒ­é¡ä¼¼åº¦ã®é–¢ä¿‚</h2>
  <canvas id="proDistanceSkillChart"></canvas>

  <h2>è‡ªå·±é¡ä¼¼åº¦ï¼ˆè·é›¢è¡Œåˆ—ã®å¹³å‡å€¤ï¼‰ã¨å¾—æ„ä¸å¾—æ„ã®é–¢ä¿‚</h2>
  <canvas id="rawSelfSkillChart"></canvas>

  <h2>è‡ªå·±é¡ä¼¼åº¦ï¼ˆè·é›¢è¡Œåˆ—ã®ä¸­å¤®å€¤ï¼‰ã¨å¾—æ„ä¸å¾—æ„ã®é–¢ä¿‚</h2>
  <canvas id="rawSelfMedianSkillChart"></canvas>




  <div id="summary"></div>

  <script>
    let historyChartInstance = null;
    let skillChartInstance = null;

    async function loadSurveySummary() {
      const res = await fetch("https://yoyo-backend.kajilab.dev/survey_summary");
      const data = await res.json();
      console.log("ğŸ”¹ survey_summary:", data);

    //   const container = document.getElementById("summary");
    //   container.innerHTML = `
    //     <h2>äº‹å‰ã‚¢ãƒ³ã‚±ãƒ¼ãƒˆ</h2>
    //     ${renderSummaryTable(data.pre)}
    //     <h2>äº‹å¾Œã‚¢ãƒ³ã‚±ãƒ¼ãƒˆ</h2>
    //     ${renderSummaryTable(data.post)}
    //   `;

      // å¹´é½¢ãƒ»é »åº¦ãƒ»ãƒ¨ãƒ¼ãƒ¨ãƒ¼æ­´ã‚°ãƒ©ãƒ•
    if (data.pre?.length) {
    drawAgeChart(data.pre);
    drawFreqChart(data.pre);
    drawHistoryChart(data.pre);
    drawTroubleChart(data.pre); // â† è¿½åŠ ï¼
    drawPracticeChart(data.pre); // â† è¿½åŠ ï¼
    drawSkillDistributionChart(data.pre); // â† ã“ã‚Œè¿½åŠ ï¼
    }




      // ã‚¹ã‚³ã‚¢ä»˜ãã®æ•£å¸ƒå›³
      if (data.pre?.length) {
    drawHistoryScoreChart(data.pre);
    drawSkillScoreChart(data.pre); // â† ã“ã‚Œè¿½åŠ ï¼
    }

    if (data.post?.length) {
    drawDiscomfortChart(data.post);
    drawWeightfitChart(data.post);

    // === ãƒ‡ãƒã‚¤ã‚¹ã‚³ãƒ¡ãƒ³ãƒˆä¸€è¦§ã‚’è¿½åŠ ï¼ˆweightfitChart ã®ç›´å¾Œã«æŒ¿å…¥ï¼‰ ===
    const htmlDevice = renderDeviceComments(data.post);
    const weightfitSection = document.getElementById("weightfitChart");
    const wrapperDevice = document.createElement("div");
    wrapperDevice.innerHTML = htmlDevice;
    weightfitSection.insertAdjacentElement("afterend", wrapperDevice);

    drawResultviewChart(data.post);
    drawUsefulChart(data.post);
    drawContinueChart(data.post);
    drawFutureTrickChart(data.post);
    }

    if (data.post?.length) {
    // === ç·åˆã‚¹ã‚³ã‚¢çµ±è¨ˆãƒ»åˆ†å¸ƒãƒ»å€‹åˆ¥ã‚°ãƒ©ãƒ• ===
    const trickSection = document.getElementById("historyScoreChart");
    const container = document.createElement("div");
    container.id = "scoreSummary";

    // 1ï¸âƒ£ çµ±è¨ˆãƒ‘ãƒãƒ«
    container.innerHTML = renderScoreSummary(data.post);

    // 2ï¸âƒ£ ãƒ’ã‚¹ãƒˆã‚°ãƒ©ãƒ 
    drawScoreHistogram(data.post, container);

    // 3ï¸âƒ£ ãƒ©ãƒ³ã‚­ãƒ³ã‚°
    drawIndividualScores(data.post, container);

    const historyHeading = [...document.querySelectorAll("h2")]
    .find(h => h.textContent.includes("ãƒ¨ãƒ¼ãƒ¨ãƒ¼æ­´ã¨ã‚¹ã‚³ã‚¢ã®é–¢ä¿‚"));

    if (historyHeading) {
    // è¦‹å‡ºã—ã‚’ã‚¹ã‚³ã‚¢ã‚µãƒãƒªãƒ¼ã®ç›´å¾Œã«ç§»å‹•
    container.insertAdjacentElement("beforeend", historyHeading);

    // ãã®è¦‹å‡ºã—ã®ä¸‹ã«æ•£å¸ƒå›³ã‚’é…ç½®
    const trickSection = document.getElementById("historyScoreChart");
    container.insertAdjacentElement("beforeend", trickSection);

    // æœ€å¾Œã« container å…¨ä½“ã‚’ã€Œå¾—æ„ä¸å¾—æ„ã€ã‚°ãƒ©ãƒ•ã®å‰ã«é…ç½®
    const skillHeading = [...document.querySelectorAll("h2")]
        .find(h => h.textContent.includes("å¾—æ„ä¸å¾—æ„ã¨ã‚¹ã‚³ã‚¢ã®é–¢ä¿‚"));
    if (skillHeading) skillHeading.insertAdjacentElement("beforebegin", container);
    }


    }

    if (data.post?.length) {
      drawProDistanceSkillChart(data.post);
      drawRawSelfDistanceSkillChart(data.post);
      drawRawSelfMedianSkillChart(data.post);
    }

 







    // === ã‚·ã‚¹ãƒ†ãƒ ã‚³ãƒ¡ãƒ³ãƒˆè¡¨ã‚’ã€Œä»Šå¾Œåˆ†æã—ã¦ã»ã—ã„ãƒˆãƒªãƒƒã‚¯ã€ã®ç›´å¾Œã«è¿½åŠ  ===
    if (data.post?.length) {
    const html = renderSystemComments(data.post);
    const trickSection = document.getElementById("futureTrickChart");
    const wrapper = document.createElement("div");
    wrapper.innerHTML = html;
    trickSection.insertAdjacentElement("afterend", wrapper);
    }

    }



    function renderSummaryTable(surveys) {
      if (!surveys?.length) return "<p>ãƒ‡ãƒ¼ã‚¿ãªã—</p>";
      const counts = {};
      surveys.forEach(s => {
        for (const [k, v] of Object.entries(s)) {
          const val = Array.isArray(v) ? v.join(", ") : v;
          counts[k] = counts[k] || {};
          counts[k][val] = (counts[k][val] || 0) + 1;
        }
      });
      return `<table>${
        Object.entries(counts)
          .map(([q, vals]) => 
            `<tr><th>${q}</th><td>${Object.entries(vals)
              .map(([ans, num]) => `${ans}: ${num}`).join("<br>")}</td></tr>`)
          .join("")
      }</table>`;
    }

    // === å¹´é½¢åˆ†å¸ƒ ===
    function drawAgeChart(preSurveys) {
      const toHalfWidth = (str) => str.replace(/[ï¼-ï¼™]/g, s => 
        String.fromCharCode(s.charCodeAt(0) - 0xFEE0)
      );

      const ages = preSurveys
        .map(s => parseInt(toHalfWidth(String(s.age || "")).trim()))
        .filter(n => !isNaN(n) && n > 0 && n < 100);

      const bins = {
        "10æ­³æœªæº€": 0, "10ä»£": 0, "20ä»£": 0, "30ä»£": 0,
        "40ä»£": 0, "50ä»£": 0, "60ä»£": 0, "70ä»£": 0
      };

      ages.forEach(a => {
        if (a < 10) bins["10æ­³æœªæº€"]++;
        else if (a < 20) bins["10ä»£"]++;
        else if (a < 30) bins["20ä»£"]++;
        else if (a < 40) bins["30ä»£"]++;
        else if (a < 50) bins["40ä»£"]++;
        else if (a < 60) bins["50ä»£"]++;
        else if (a < 70) bins["60ä»£"]++;
        else bins["70ä»£"]++;
      });

      const ctx = document.getElementById("ageChart").getContext("2d");
      new Chart(ctx, {
        type: "bar",
        data: {
          labels: Object.keys(bins),
          datasets: [{
            label: "å¹´é½¢åˆ†å¸ƒï¼ˆ10æ­³åˆ»ã¿ï¼‰",
            data: Object.values(bins),
            backgroundColor: "rgba(54, 162, 235, 0.6)"
          }]
        },
        options: { responsive: false, scales: { y: { beginAtZero: true } } }
      });
    }

    // === ãƒ¨ãƒ¼ãƒ¨ãƒ¼æ­´ï¼ˆã‚¢ãƒ³ã‚±ãƒ¼ãƒˆå›ç­”ï¼‰ ===
function drawHistoryChart(preSurveys) {
  // ãƒ‡ãƒ¼ã‚¿ã‚’æ­£è¦åŒ–ï¼ˆå…¨è§’â†’åŠè§’ã€è¡¨è¨˜ã‚†ã‚Œçµ±ä¸€ï¼‰
  const normalize = (str) =>
    (str || "")
      .replace(/[ï¼¡-ï¼ºï½-ï½šï¼-ï¼™]/g, s => String.fromCharCode(s.charCodeAt(0) - 0xFEE0))
      .replace(/[ã€œï½]/g, "ï½")
      .replace(/(ã‚«æœˆ|ãƒ¶æœˆ)/g, "ã‹æœˆ")
      .replace(/\s+/g, "")
      .trim();

  const categories = [
    "ã¯ã˜ã‚ã¦",
    "3ã‹æœˆæœªæº€",
    "3ã‹æœˆï½åŠå¹´",
    "åŠå¹´ï½1å¹´",
    "1ï½2å¹´",
    "3ï½4å¹´",
    "5å¹´ä»¥ä¸Š"
  ];

  // å„ã‚«ãƒ†ã‚´ãƒªã®ã‚«ã‚¦ãƒ³ãƒˆ
  const historyBins = Object.fromEntries(categories.map(c => [c, 0]));

  preSurveys.forEach(s => {
    const h = normalize(s.history);
    if (historyBins.hasOwnProperty(h)) {
      historyBins[h]++;
    }
  });

  const labels = Object.keys(historyBins);
  const values = Object.values(historyBins);

  const ctx = document.getElementById("historyChart").getContext("2d");
  new Chart(ctx, {
    type: "bar",
    data: {
      labels: labels,
      datasets: [{
        label: "ãƒ¨ãƒ¼ãƒ¨ãƒ¼æ­´ï¼ˆäººæ•°ï¼‰",
        data: values,
        backgroundColor: [
          "rgba(255, 159, 64, 0.6)",
          "rgba(255, 205, 86, 0.6)",
          "rgba(75, 192, 192, 0.6)",
          "rgba(54, 162, 235, 0.6)",
          "rgba(153, 102, 255, 0.6)",
          "rgba(201, 203, 207, 0.6)",
          "rgba(255, 99, 132, 0.6)"
        ],
        borderColor: "rgba(0, 0, 0, 0.2)",
        borderWidth: 1
      }]
    },
    options: {
      responsive: false,
      plugins: {
        title: {
          display: true,
          text: "ãƒ¨ãƒ¼ãƒ¨ãƒ¼æ­´",
          font: { size: 18 }
        },
        legend: { display: false }
      },
      scales: {
        x: {
          title: { display: true, text: "ãƒ¨ãƒ¼ãƒ¨ãƒ¼æ­´" },
          ticks: { font: { size: 14 } }
        },
        y: {
          title: { display: true, text: "äººæ•°" },
          beginAtZero: true,
          ticks: { stepSize: 1 }
        }
      }
    }
  });
}


    // === ãƒ¨ãƒ¼ãƒ¨ãƒ¼ã‚’ã™ã‚‹é »åº¦ ===
function drawFreqChart(preSurveys) {
  // freqã®å›ç­”ã‚’ã‚«ã‚¦ãƒ³ãƒˆ
  const freqBins = {
    "ã»ã¨ã‚“ã©ã—ãªã„": 0,
    "æœˆã«æ•°å›": 0,
    "é€±ã«1ï½2å›": 0,
    "é€±ã«3ï½4å›": 0,
    "ã»ã¼æ¯æ—¥": 0
  };

  preSurveys.forEach(s => {
    const val = s.freq?.trim();
    if (val && freqBins.hasOwnProperty(val)) freqBins[val]++;
  });

  const labels = Object.keys(freqBins);
  const values = Object.values(freqBins);

  const ctx = document.getElementById("freqChart").getContext("2d");
  new Chart(ctx, {
    type: "bar",
    data: {
      labels: labels,
      datasets: [{
        label: "ãƒ¨ãƒ¼ãƒ¨ãƒ¼ã‚’ã™ã‚‹é »åº¦",
        data: values,
        backgroundColor: [
          "rgba(255, 159, 64, 0.6)",
          "rgba(75, 192, 192, 0.6)",
          "rgba(54, 162, 235, 0.6)",
          "rgba(153, 102, 255, 0.6)",
          "rgba(255, 99, 132, 0.6)"
        ],
        borderColor: "rgba(0, 0, 0, 0.2)",
        borderWidth: 1
      }]
    },
    options: {
      responsive: false,
      plugins: {
        title: {
          display: true,
          text: "ãƒ¨ãƒ¼ãƒ¨ãƒ¼ã‚’ã™ã‚‹é »åº¦",
          font: { size: 18 }
        },
        legend: { display: false }
      },
      scales: {
        x: { title: { display: true, text: "å›ç­”" } },
        y: {
          title: { display: true, text: "äººæ•°" },
          beginAtZero: true,
          ticks: { stepSize: 1 }
        }
      }
    }
  });
}

// === ç·´ç¿’æ–¹æ³•ï¼ˆè¤‡æ•°å›ç­”ï¼‰ ===
function drawPracticeChart(preSurveys) {
  // å„é¸æŠè‚¢ã®å‡ºç¾å›æ•°ã‚’ã‚«ã‚¦ãƒ³ãƒˆ
  const counts = {
    "1äººã§": 0,
    "å‹é”ã¨": 0,
    "è§£èª¬å‹•ç”»ã‚’è¦‹ãªãŒã‚‰": 0,
    "ç·´ç¿’ä¼šã«å‚åŠ ": 0,
    "ãã®ä»–": 0
  };

  preSurveys.forEach(s => {
    if (!s.practice) return;
    const practices = Array.isArray(s.practice)
      ? s.practice
      : String(s.practice).split(",").map(t => t.trim());
    practices.forEach(p => {
      if (counts[p] !== undefined) counts[p]++;
    });
  });

  const labels = Object.keys(counts);
  const values = Object.values(counts);

  const ctx = document.getElementById("practiceChart").getContext("2d");
  new Chart(ctx, {
    type: "bar",
    data: {
      labels: labels,
      datasets: [{
        label: "å›ç­”äººæ•°",
        data: values,
        backgroundColor: "rgba(75, 192, 192, 0.6)"
      }]
    },
    options: {
      indexAxis: "y", // æ¨ªæ£’ã‚°ãƒ©ãƒ•
      responsive: false,
      plugins: {
        title: {
          display: true,
          text: "æ™®æ®µã©ã®ã‚ˆã†ã«ãƒ¨ãƒ¼ãƒ¨ãƒ¼ã‚’ç·´ç¿’ã—ã¦ã„ã¾ã™ã‹ï¼Ÿï¼ˆè¤‡æ•°å›ç­”å¯ï¼‰",
          font: { size: 18 }
        },
        legend: { display: false }
      },
      scales: {
        x: {
          beginAtZero: true,
          title: { display: true, text: "äººæ•°" },
          ticks: { stepSize: 2 }
        },
        y: {
          title: { display: true, text: "ç·´ç¿’æ–¹æ³•" }
        }
      }
    }
  });
}



// === å›°ã£ã¦ã„ã‚‹ã“ã¨ï¼ˆè¤‡æ•°å›ç­”ï¼‰ ===
function drawTroubleChart(preSurveys) {
  // å„é¸æŠè‚¢ã®å‡ºç¾å›æ•°ã‚’ã‚«ã‚¦ãƒ³ãƒˆ
  const counts = {
    "ãƒˆãƒªãƒƒã‚¯ãŒå®‰å®šã—ãªã„": 0,
    "æ€ã†ã‚ˆã†ã«ä¸Šé”ã—ãªã„": 0,
    "ã§ãã¦ã„ã‚‹ã‹ã©ã†ã‹ã‚ã‹ã‚‰ãªã„": 0,
    "æ•™ãˆã¦ãã‚Œã‚‹äººãŒã„ãªã„": 0,
    "ãã®ä»–": 0
  };

  preSurveys.forEach(s => {
    if (!s.trouble) return;
    const troubles = Array.isArray(s.trouble)
      ? s.trouble
      : String(s.trouble).split(",").map(t => t.trim());
    troubles.forEach(t => {
      if (counts[t] !== undefined) counts[t]++;
    });
  });

  const labels = Object.keys(counts);
  const values = Object.values(counts);

  const ctx = document.getElementById("troubleChart").getContext("2d");
  new Chart(ctx, {
    type: "bar",
    data: {
      labels: labels,
      datasets: [{
        label: "å›°ã£ã¦ã„ã‚‹äººã®æ•°",
        data: values,
        backgroundColor: "rgba(255, 99, 132, 0.6)"
      }]
    },
    options: {
      indexAxis: "y", // â† æ¨ªå‘ãæ£’ã‚°ãƒ©ãƒ•
      responsive: false,
      plugins: {
        title: {
          display: true,
          text: "ç·´ç¿’ã§å›°ã£ã¦ã„ã‚‹ã“ã¨ï¼ˆè¤‡æ•°å›ç­”å¯ï¼‰",
          font: { size: 18 }
        },
        legend: { display: false }
      },
      scales: {
        x: {
          beginAtZero: true,
          title: { display: true, text: "äººæ•°" },
          ticks: { stepSize: 2 }
        },
        y: {
          title: { display: true, text: "å›°ã£ã¦ã„ã‚‹ã“ã¨" }
        }
      }
    }
  });
}

// === å¾—æ„åº¦ï¼ˆ0ã€œ5ï¼‰ ===
function drawSkillDistributionChart(preSurveys) {
  const counts = [0, 0, 0, 0, 0, 0]; // 0ã€œ5ã®ã‚«ã‚¦ãƒ³ãƒˆé…åˆ—

  preSurveys.forEach(s => {
    const num = parseInt(s.skill);
    if (!isNaN(num) && num >= 0 && num <= 5) counts[num]++;
  });

  const ctx = document.getElementById("skillDistributionChart").getContext("2d");
  new Chart(ctx, {
    type: "bar",
    data: {
      labels: ["0", "1", "2", "3", "4", "5"],
      datasets: [{
        label: "å›ç­”äººæ•°",
        data: counts,
        backgroundColor: "rgba(153, 102, 255, 0.6)"
      }]
    },
    options: {
      responsive: false,
      plugins: {
        title: {
          display: true,
          text: "ãƒ¨ãƒ¼ãƒ¨ãƒ¼ã®å¾—æ„åº¦åˆ†å¸ƒï¼ˆ0=ä¸å¾—æ„, 5=å¾—æ„ï¼‰",
          font: { size: 18 }
        },
        legend: { display: false }
      },
      scales: {
        x: {
          title: { display: true, text: "å¾—æ„åº¦ï¼ˆè‡ªå·±è©•ä¾¡ï¼‰" }
        },
        y: {
          beginAtZero: true,
          title: { display: true, text: "äººæ•°" },
          ticks: { stepSize: 2 }
        }
      }
    }
  });
}

// === ãƒ‡ãƒã‚¤ã‚¹é•å’Œæ„Ÿã®åˆ†å¸ƒ ===
function drawDiscomfortChart(postSurveys) {
  // å›ç­”ã®ã‚«ã‚¦ãƒ³ãƒˆã‚’åˆæœŸåŒ–
  const bins = {
    "å…¨ããªã‹ã£ãŸ": 0,
    "å°‘ã—ã‚ã£ãŸ": 0,
    "ã‹ãªã‚Šã‚ã£ãŸ": 0
  };

  postSurveys.forEach(s => {
    if (s.discomfort && bins.hasOwnProperty(s.discomfort)) {
      bins[s.discomfort]++;
    }
  });

  const ctx = document.getElementById("discomfortChart").getContext("2d");
  new Chart(ctx, {
    type: "bar",
    data: {
      labels: Object.keys(bins),
      datasets: [{
        label: "å›ç­”äººæ•°",
        data: Object.values(bins),
        backgroundColor: [
          "rgba(75, 192, 192, 0.7)", // å…¨ããªã‹ã£ãŸ
          "rgba(255, 205, 86, 0.7)", // å°‘ã—ã‚ã£ãŸ
          "rgba(255, 99, 132, 0.7)"  // ã‹ãªã‚Šã‚ã£ãŸ
        ]
      }]
    },
    options: {
      indexAxis: "y", // æ¨ªæ£’ã‚°ãƒ©ãƒ•
      responsive: false,
      plugins: {
        legend: { display: false },
        title: {
          display: true,
          text: "ãƒ‡ãƒã‚¤ã‚¹è£…ç€æ™‚ã®é•å’Œæ„Ÿ",
          font: { size: 18 }
        }
      },
      scales: {
        x: {
          beginAtZero: true,
          title: { display: true, text: "äººæ•°" },
          ticks: { stepSize: 5 }
        },
        y: {
          title: { display: true, text: "å›ç­”å†…å®¹" }
        }
      }
    }
  });
}


// === é‡ã•ãƒ»è£…ç€æ€§ã«é–¢ã™ã‚‹è©•ä¾¡ ===
function drawWeightfitChart(postSurveys) {
  const bins = {
    "æ°—ã«ãªã‚‰ãªã‹ã£ãŸ": 0,
    "å°‘ã—æ°—ã«ãªã£ãŸ": 0,
    "ã¨ã¦ã‚‚æ°—ã«ãªã£ãŸ": 0
  };

  postSurveys.forEach(s => {
    if (s.weightfit && bins.hasOwnProperty(s.weightfit)) {
      bins[s.weightfit]++;
    }
  });

  const ctx = document.getElementById("weightfitChart").getContext("2d");
  new Chart(ctx, {
    type: "bar",
    data: {
      labels: Object.keys(bins),
      datasets: [{
        label: "å›ç­”äººæ•°",
        data: Object.values(bins),
        backgroundColor: [
          "rgba(75, 192, 192, 0.7)", // æ°—ã«ãªã‚‰ãªã‹ã£ãŸ
          "rgba(255, 205, 86, 0.7)", // å°‘ã—æ°—ã«ãªã£ãŸ
          "rgba(255, 99, 132, 0.7)"  // ã¨ã¦ã‚‚æ°—ã«ãªã£ãŸ
        ]
      }]
    },
    options: {
      indexAxis: "y", // â† æ¨ªæ£’ã‚°ãƒ©ãƒ•
      responsive: false,
      plugins: {
        legend: { display: false },
        title: {
          display: true,
          text: "ãƒ‡ãƒã‚¤ã‚¹ã®é‡ã•ãƒ»è£…ç€æ€§ã«é–¢ã™ã‚‹å°è±¡",
          font: { size: 18 }
        }
      },
      scales: {
        x: {
          beginAtZero: true,
          title: { display: true, text: "äººæ•°" },
          ticks: { stepSize: 5 }
        },
        y: {
          title: { display: true, text: "å›ç­”å†…å®¹" }
        }
      }
    }
  });
}

// === device-comment ä¸€è¦§è¡¨ç¤º ===
function renderDeviceComments(postSurveys) {
  const valid = postSurveys
    .filter(p => p["device-comment"] && p["device-comment"].trim() !== ":");

  if (!valid.length) return "<p>ã‚³ãƒ¡ãƒ³ãƒˆãªã—</p>";

  const rows = valid.map(p =>
    `<tr><td>${p.name || `ID:${p.id}`}</td><td>${p["device-comment"]}</td></tr>`
  ).join("");

  return `
    <h2>3.ãƒ‡ãƒã‚¤ã‚¹ã«ã¤ã„ã¦ã‚ˆã‹ã£ãŸç‚¹ãƒ»æ”¹å–„ã—ã¦ã»ã—ã„ç‚¹ã‚’æ•™ãˆã¦ãã ã•ã„</h2>
    <table border="1" style="margin:10px auto; border-collapse:collapse; font-size:18px;">
      <tr><th>åå‰</th><th>ã‚³ãƒ¡ãƒ³ãƒˆå†…å®¹</th></tr>
      ${rows}
    </table>`;
}


// === è©•ä¾¡çµæœã®ã‚ã‹ã‚Šã‚„ã™ã• ===
function drawResultviewChart(postSurveys) {
  // ã™ã¹ã¦ã®é¸æŠè‚¢ã‚’æ˜ç¤ºï¼ˆ0ä»¶ã§ã‚‚è¡¨ç¤ºï¼‰
  const bins = {
    "ã¨ã¦ã‚‚ã‚ã‹ã‚Šã‚„ã™ã„": 0,
    "ã‚ã‹ã‚Šã‚„ã™ã„": 0,
    "å°‘ã—ã‚ã‹ã‚Šã«ãã„": 0,
    "ã‚ã‹ã‚Šã«ãã„": 0
  };

  // å›ç­”ã‚’ã‚«ã‚¦ãƒ³ãƒˆ
  postSurveys.forEach(s => {
    if (s.resultview && bins.hasOwnProperty(s.resultview)) {
      bins[s.resultview]++;
    }
  });

  // ã‚°ãƒ©ãƒ•æç”»
  const ctx = document.getElementById("resultviewChart").getContext("2d");
  new Chart(ctx, {
    type: "bar",
    data: {
      labels: Object.keys(bins),
      datasets: [{
        label: "å›ç­”äººæ•°",
        data: Object.values(bins),
        backgroundColor: [
          "rgba(54, 162, 235, 0.7)",  // ã¨ã¦ã‚‚ã‚ã‹ã‚Šã‚„ã™ã„
          "rgba(75, 192, 192, 0.7)",  // ã‚ã‹ã‚Šã‚„ã™ã„
          "rgba(255, 205, 86, 0.7)",  // å°‘ã—ã‚ã‹ã‚Šã«ãã„
          "rgba(255, 99, 132, 0.7)"   // ã‚ã‹ã‚Šã«ãã„ï¼ˆ0ä»¶ã§ã‚‚ã‚°ãƒ¬ãƒ¼ã‚¢ã‚¦ãƒˆé¢¨ï¼‰
        ]
      }]
    },
    options: {
      indexAxis: "y", // â† æ¨ªæ£’ã‚°ãƒ©ãƒ•
      responsive: false,
      plugins: {
        legend: { display: false },
        title: {
          display: true,
          text: "è©•ä¾¡çµæœã®ã‚ã‹ã‚Šã‚„ã™ã•",
          font: { size: 18 }
        }
      },
      scales: {
        x: {
          beginAtZero: true,
          title: { display: true, text: "äººæ•°" },
          ticks: { stepSize: 5 }
        },
        y: {
          title: { display: true, text: "å›ç­”å†…å®¹" }
        }
      }
    }
  });
}

// === è©•ä¾¡çµæœã®æœ‰ç”¨æ€§ï¼ˆä»Šå¾Œã®ç·´ç¿’ã®å‚è€ƒã«ãªã£ãŸã‹ï¼‰ ===
function drawUsefulChart(postSurveys) {
  // ã™ã¹ã¦ã®é¸æŠè‚¢ã‚’æ˜ç¤ºï¼ˆ0ä»¶ã§ã‚‚è¡¨ç¤ºï¼‰
  const bins = {
    "ã¨ã¦ã‚‚æ€ã†": 0,
    "å°‘ã—æ€ã†": 0,
    "ã‚ã¾ã‚Šæ€ã‚ãªã„": 0,
    "å…¨ãæ€ã‚ãªã„": 0
  };

  // å›ç­”ã‚’ã‚«ã‚¦ãƒ³ãƒˆï¼ˆæœªå›ç­”ã¯ç„¡è¦–ï¼‰
  postSurveys.forEach(s => {
    if (s.useful && bins.hasOwnProperty(s.useful)) {
      bins[s.useful]++;
    }
  });

  // ã‚°ãƒ©ãƒ•æç”»
  const ctx = document.getElementById("usefulChart").getContext("2d");
  new Chart(ctx, {
    type: "bar",
    data: {
      labels: Object.keys(bins),
      datasets: [{
        label: "å›ç­”äººæ•°",
        data: Object.values(bins),
        backgroundColor: [
          "rgba(54, 162, 235, 0.7)",  // ã¨ã¦ã‚‚æ€ã†
          "rgba(75, 192, 192, 0.7)",  // å°‘ã—æ€ã†
          "rgba(255, 205, 86, 0.7)",  // ã‚ã¾ã‚Šæ€ã‚ãªã„
          "rgba(255, 99, 132, 0.7)"   // å…¨ãæ€ã‚ãªã„
        ]
      }]
    },
    options: {
      indexAxis: "y", // â† æ¨ªæ£’ã‚°ãƒ©ãƒ•
      responsive: false,
      plugins: {
        legend: { display: false },
        title: {
          display: true,
          text: "è©•ä¾¡çµæœã®æœ‰ç”¨æ€§ï¼ˆä»Šå¾Œã®ç·´ç¿’ã®å‚è€ƒã«ãªã£ãŸã‹ï¼‰",
          font: { size: 18 }
        }
      },
      scales: {
        x: {
          beginAtZero: true,
          title: { display: true, text: "äººæ•°" },
          ticks: { stepSize: 5 }
        },
        y: {
          title: { display: true, text: "å›ç­”å†…å®¹" }
        }
      }
    }
  });
}


// === ä»Šå¾Œã‚‚ä½¿ã„ãŸã„ã‹ï¼ˆç¶™ç¶šæ„å‘ï¼‰ ===
function drawContinueChart(postSurveys) {
  // å…¨é¸æŠè‚¢ã‚’åˆæœŸåŒ–ï¼ˆ0ä»¶ã§ã‚‚è»¸ã«è¡¨ç¤ºï¼‰
  const bins = {
    "ãœã²ä½¿ã„ãŸã„": 0,
    "æ©Ÿä¼šãŒã‚ã‚Œã°ä½¿ã„ãŸã„": 0,
    "ã‚ã¾ã‚Šä½¿ã„ãŸã„ã¨æ€ã‚ãªã„": 0
  };

  // å›ç­”ã‚’ã‚«ã‚¦ãƒ³ãƒˆï¼ˆæœªå›ç­”ã¯ç„¡è¦–ï¼‰
  postSurveys.forEach(s => {
    if (s.continue && bins.hasOwnProperty(s.continue)) {
      bins[s.continue]++;
    }
  });

  // ã‚°ãƒ©ãƒ•æç”»
  const ctx = document.getElementById("continueChart").getContext("2d");
  new Chart(ctx, {
    type: "bar",
    data: {
      labels: Object.keys(bins),
      datasets: [{
        label: "å›ç­”äººæ•°",
        data: Object.values(bins),
        backgroundColor: [
          "rgba(54, 162, 235, 0.7)",  // ãœã²ä½¿ã„ãŸã„
          "rgba(75, 192, 192, 0.7)",  // æ©Ÿä¼šãŒã‚ã‚Œã°ä½¿ã„ãŸã„
          "rgba(255, 99, 132, 0.7)"   // ã‚ã¾ã‚Šä½¿ã„ãŸã„ã¨æ€ã‚ãªã„
        ]
      }]
    },
    options: {
      indexAxis: "y", // â† æ¨ªæ£’ã‚°ãƒ©ãƒ•
      responsive: false,
      plugins: {
        legend: { display: false },
        title: {
          display: true,
          text: "ä»Šå¾Œã‚‚ä½¿ã„ãŸã„ã‹ï¼ˆç¶™ç¶šæ„å‘ï¼‰",
          font: { size: 18 }
        }
      },
      scales: {
        x: {
          beginAtZero: true,
          title: { display: true, text: "äººæ•°" },
          ticks: { stepSize: 5 }
        },
        y: {
          title: { display: true, text: "å›ç­”å†…å®¹" }
        }
      }
    }
  });
}

function drawFutureTrickChart(postSurveys) {
  const labels = [
    "ãƒ›ãƒƒãƒ—ã‚¶ãƒ•ã‚§ãƒ³ã‚¹", "ãƒ€ãƒ–ãƒ«ãƒ«ãƒ¼ãƒ—", "ã‚¤ãƒ¼ãƒ©ã‚¤ãƒ›ãƒƒãƒ—", "ãƒ•ãƒƒã‚¯", "ãƒœãƒ¨ãƒ³ãƒœãƒ¨ãƒ³",
    "ã‚¸ãƒ£ãƒ¼ãƒ–ãƒ«", "ãƒ©ã‚»ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³", "ãƒˆãƒ©ãƒ”ãƒ¼ã‚º", "ã‚¹ãƒˆãƒªãƒ³ã‚°ãƒˆãƒªãƒƒã‚¯",
    "ã‚¢ã‚¦ãƒˆã‚µã‚¤ãƒ‰ãƒ«ãƒ¼ãƒ—", "ã‚¢ãƒ©ã‚¦ãƒ³ãƒ‰ã‚¶ãƒ¯ãƒ¼ãƒ«ãƒ‰",
    "ã‚·ãƒ¥ãƒ¼ãƒˆã‚¶ãƒ ãƒ¼ãƒ³", "ã‚ªãƒ¼ãƒãƒ¼ã‚¶ãƒ•ã‚§ãƒ³ã‚¹", "ãƒ­ãƒ¼ãƒ©ãƒ¼ã‚³ãƒ¼ã‚¹ã‚¿ãƒ¼",
    "ã‚­ãƒ£ãƒ³ãƒ‡ã‚£ãƒ¬ã‚¤ãƒ³", "ãƒ©ãƒƒãƒ—ç³»ãƒˆãƒªãƒƒã‚¯", "ãƒ–ãƒ¬ã‚¤ãƒ³ãƒ„ã‚¤ã‚¹ã‚¿ãƒ¼ã‚³ãƒ³ãƒœ",
    "ãƒ•ã‚¡ã‚¦ãƒ³ãƒ†ãƒ³", "ã‚¹ãƒªãƒ¼ãƒ‘ãƒ¼", "ãƒ—ãƒ­ãƒšãƒ©", "5A", "1A", "L.C.L",
    "ãƒ„ãƒ¼ãƒãƒ³ãƒ‰ãƒˆãƒ©ãƒ”ãƒ¼ã‚º", "ã‚½ãƒ­ãƒãƒ "
  ];

  const counts = {};
  labels.forEach(label => counts[label] = 0);

  postSurveys.forEach(s => {
    const val = (s["future-trick"] || "").trim();
    if (!val || val === ":") return;
    const tricks = val.split(",").map(t => t.trim()).filter(Boolean);
    tricks.forEach(t => {
      if (counts.hasOwnProperty(t)) counts[t]++;
    });
  });

  const sorted = Object.entries(counts).sort((a, b) => b[1] - a[1]);
  const sortedLabels = sorted.map(([k]) => k);
  const values = sorted.map(([, v]) => v);

  // âœ… ãƒ©ãƒ™ãƒ«æ•°ã«å¿œã˜ã¦ã‚­ãƒ£ãƒ³ãƒã‚¹é«˜ã•ã‚’è‡ªå‹•èª¿æ•´
  const canvas = document.getElementById("futureTrickChart");
  const barHeight = 35; // 1é …ç›®ã‚ãŸã‚Šã®é«˜ã•(px)
  canvas.height = sortedLabels.length * barHeight;

  const ctx = canvas.getContext("2d");
  new Chart(ctx, {
    type: "bar",
    data: {
      labels: sortedLabels,
      datasets: [{
        label: "å¸Œæœ›äººæ•°",
        data: values,
        backgroundColor: "rgba(54, 162, 235, 0.7)"
      }]
    },
    options: {
      indexAxis: "y",
      responsive: false,
      plugins: {
        legend: { display: false },
        title: {
          display: true,
          text: "ä»Šå¾Œåˆ†æã—ã¦ã»ã—ã„ãƒˆãƒªãƒƒã‚¯ï¼ˆè¤‡æ•°å›ç­”å«ã‚€ï¼‰",
          font: { size: 18 }
        }
      },
      scales: {
        x: {
          beginAtZero: true,
          ticks: { stepSize: 1 },
          title: { display: true, text: "å›ç­”äººæ•°" }
        },
        y: {
          title: { display: true, text: "ãƒˆãƒªãƒƒã‚¯å" }
        }
      }
    }
  });
}

// === system-comment ä¸€è¦§è¡¨ç¤º ===
function renderSystemComments(postSurveys) {
  const valid = postSurveys
    .filter(p => p["system-comment"] && p["system-comment"].trim() !== ":");

  if (!valid.length) {
    return "<p>ã‚³ãƒ¡ãƒ³ãƒˆãªã—</p>";
  }

  const rows = valid.map(p =>
    `<tr><td>${p.name || `ID:${p.id}`}</td><td>${p["system-comment"]}</td></tr>`
  ).join("");

  return `
    <h2>8.ã‚·ã‚¹ãƒ†ãƒ ã«ã¤ã„ã¦ã‚ˆã‹ã£ãŸç‚¹ãƒ»æ”¹å–„ã—ã¦ã»ã—ã„ç‚¹ã‚’æ•™ãˆã¦ãã ã•ã„</h2>
    <table border="1" style="margin:10px auto; border-collapse:collapse; font-size:18px;">
      <tr><th>åå‰</th><th>ã‚³ãƒ¡ãƒ³ãƒˆå†…å®¹</th></tr>
      ${rows}
    </table>`;
}

// === ç·åˆã‚¹ã‚³ã‚¢ã®çµ±è¨ˆãƒ‘ãƒãƒ« ===
function renderScoreSummary(data) {
  const scores = data.map(d => parseFloat(d.total_score)).filter(s => !isNaN(s));
  if (!scores.length) return "<p>ã‚¹ã‚³ã‚¢ãƒ‡ãƒ¼ã‚¿ãªã—</p>";

  const avg = (scores.reduce((a, b) => a + b, 0) / scores.length).toFixed(2);
  const max = Math.max(...scores).toFixed(1);
  const min = Math.min(...scores).toFixed(1);

  return `
    <div style="margin:40px auto; width:80%; text-align:center;">
      <p style="font-size:22px;">
        å¹³å‡ï¼š<b>${avg}</b> ç‚¹ã€€|ã€€
        æœ€é«˜ï¼š<b>${max}</b> ç‚¹ã€€|ã€€
        æœ€ä½ï¼š<b>${min}</b> ç‚¹ã€€|ã€€
        å›ç­”æ•°ï¼š${scores.length}
      </p>
    </div>
  `;
}


// === ã‚¹ã‚³ã‚¢åˆ†å¸ƒãƒ’ã‚¹ãƒˆã‚°ãƒ©ãƒ  ===
function drawScoreHistogram(data, container = document.getElementById("scoreSummary")) {
  const scores = data.map(d => parseFloat(d.total_score)).filter(s => !isNaN(s));
  if (!scores.length) return;

  const bins = Array(10).fill(0);
  scores.forEach(s => {
    const idx = Math.min(9, Math.floor(s / 10));
    bins[idx]++;
  });

  const labels = ["0â€“10", "10â€“20", "20â€“30", "30â€“40", "40â€“50", "50â€“60", "60â€“70", "70â€“80", "80â€“90", "90â€“100"];

  const canvas = document.createElement("canvas");
  canvas.id = "scoreHistogramChart";
  canvas.width = 1000;
  canvas.height = 400;
  container.appendChild(canvas);

  const ctx = canvas.getContext("2d");
  new Chart(ctx, {
    type: "bar",
    data: {
      labels: labels,
      datasets: [{
        label: "äººæ•°",
        data: bins,
        backgroundColor: "rgba(75, 192, 192, 0.7)",
        borderColor: "rgba(0,0,0,0.2)",
        borderWidth: 1
      }]
    },
    options: {
      responsive: false,
      plugins: {
        title: { display: true, text: "ç‚¹æ•°åˆ†å¸ƒ", font: { size: 18 } },
        legend: { display: false }
      },
      scales: {
        x: { title: { display: true, text: "ã‚¹ã‚³ã‚¢ç¯„å›²" } },
        y: { title: { display: true, text: "äººæ•°" }, beginAtZero: true }
      }
    }
  });
}





// === å€‹åˆ¥ã‚¹ã‚³ã‚¢ãƒ©ãƒ³ã‚­ãƒ³ã‚°ï¼ˆæ¨ªæ£’ã‚°ãƒ©ãƒ•ï¼‰ ===
function drawIndividualScores(data, container = document.getElementById("scoreSummary")) {
  const sorted = data
    .map(d => ({ name: d.name || `ID:${d.id}`, score: parseFloat(d.total_score) }))
    .filter(d => !isNaN(d.score))
    .sort((a, b) => b.score - a.score);

  const labels = sorted.map(d => d.name);
  const values = sorted.map(d => d.score);

  const canvas = document.createElement("canvas");
  canvas.id = "scoreRankChart";
  canvas.width = 1000;
  canvas.height = labels.length * 30 + 100;
  container.appendChild(canvas);

  const ctx = canvas.getContext("2d");
  new Chart(ctx, {
    type: "bar",
    data: {
      labels: labels,
      datasets: [{
        label: "ç·åˆè©•ä¾¡ï¼ˆç‚¹ï¼‰",
        data: values,
        backgroundColor: "rgba(153, 102, 255, 0.7)"
      }]
    },
    options: {
      indexAxis: "y",
      responsive: false,
      plugins: {
        title: { display: true, text: "å‚åŠ è€…åˆ¥ç‚¹æ•°", font: { size: 18 } },
        legend: { display: false }
      },
      scales: {
        x: { beginAtZero: true, max: 100, title: { display: true, text: "ã‚¹ã‚³ã‚¢ï¼ˆç‚¹ï¼‰" } },
        y: { title: { display: true, text: "å‚åŠ è€…åï¼ˆIDï¼‰" } }
      }
    }
  });
}














    // === æ•£å¸ƒå›³ ===
    function drawHistoryScoreChart(preSurveys) {
  if (historyChartInstance) historyChartInstance.destroy();

  // --- å…¨è§’â†’åŠè§’ï¼‹æ•´å½¢ ---
  const normalize = (str) =>
    (str || "")
      .replace(/[ï¼¡-ï¼ºï½-ï½šï¼-ï¼™]/g, s => String.fromCharCode(s.charCodeAt(0) - 0xFEE0))
      .replace(/[ã€œï½]/g, "ï½")
      .replace(/(ã‚«æœˆ|ãƒ¶æœˆ)/g, "ã‹æœˆ")
      .replace(/\s+/g, "")
      .trim();

  const categories = [
    "ã¯ã˜ã‚ã¦",
    "3ã‹æœˆæœªæº€",
    "3ã‹æœˆï½åŠå¹´",
    "åŠå¹´ï½1å¹´",
    "1ï½2å¹´",
    "3ï½4å¹´",
    "5å¹´ä»¥ä¸Š"
  ];

  const mapHistoryToIndex = (history) => {
    const h = normalize(history);
    return categories.findIndex(cat => h === cat);
  };

  // --- ãƒ‡ãƒ¼ã‚¿ç‚¹ã‚’æ•°å€¤è»¸ã«å¤‰æ› ---
  const numericData = preSurveys
    .map(s => {
      const idx = mapHistoryToIndex(s.history);
      const score = parseFloat(s.total_score);
      return idx >= 0 && !isNaN(score) ? { x: idx, y: score, id: s.id } : null;
    })
    .filter(Boolean);

  if (!numericData.length) {
    console.warn("âš ï¸ æ•£å¸ƒå›³ãƒ‡ãƒ¼ã‚¿ãŒç©ºã§ã™ã€‚");
    return;
  }

  // --- å›å¸°ç›´ç·šã‚’è¨ˆç®—ï¼ˆæœ€å°äºŒä¹—æ³•ï¼‰ ---
  const n = numericData.length;
  const meanX = numericData.reduce((a, p) => a + p.x, 0) / n;
  const meanY = numericData.reduce((a, p) => a + p.y, 0) / n;

  let num = 0, den = 0;
  numericData.forEach(p => {
    num += (p.x - meanX) * (p.y - meanY);
    den += (p.x - meanX) ** 2;
  });

  const slope = num / den; // å‚¾ã
  const intercept = meanY - slope * meanX; // åˆ‡ç‰‡

  // --- ç›¸é–¢ä¿‚æ•° r ---
  const numerator = numericData.reduce((a, p) => a + (p.x - meanX) * (p.y - meanY), 0);
  const denomX = Math.sqrt(numericData.reduce((a, p) => a + (p.x - meanX) ** 2, 0));
  const denomY = Math.sqrt(numericData.reduce((a, p) => a + (p.y - meanY) ** 2, 0));
  const r = numerator / (denomX * denomY);

  console.log(`âœ… å›å¸°ç·š: y = ${slope.toFixed(2)}x + ${intercept.toFixed(2)}, r=${r.toFixed(3)}`);

  // --- å›å¸°ç›´ç·šãƒ‡ãƒ¼ã‚¿ã‚’ç”Ÿæˆ ---
  const linePoints = [
    { x: 0, y: slope * 0 + intercept },
    { x: categories.length - 1, y: slope * (categories.length - 1) + intercept }
  ];

  // --- æç”» ---
  const ctx = document.getElementById("historyScoreChart").getContext("2d");
  historyChartInstance = new Chart(ctx, {
    type: "scatter",
    data: {
      datasets: [
        {
          label: "ãƒ¨ãƒ¼ãƒ¨ãƒ¼æ­´ã¨ã‚¹ã‚³ã‚¢",
          data: numericData.map(p => ({ x: categories[p.x], y: p.y, id: p.id })),
          backgroundColor: "rgba(255, 99, 132, 0.7)",
          borderColor: "rgba(255, 99, 132, 1)",
          pointRadius: 7
        },
        {
          label: `å›å¸°ç·šï¼ˆr=${r.toFixed(3)}ï¼‰`,
          type: "line",
          data: linePoints.map(p => ({ x: categories[p.x], y: p.y })),
          borderColor: "rgba(0, 0, 0, 0.8)",
          borderWidth: 2,
          fill: false,
          pointRadius: 0
        }
      ]
    },
    options: {
      onClick: (evt, elements) => {
        if (elements.length > 0) {
            const idx = elements[0].index;
            const dataset = historyChartInstance.data.datasets[elements[0].datasetIndex];
            const point = dataset.data[idx];
            const id = point.id;
            if (id) {
            window.open(`viewer.html?id=${id}`, "_blank");
            }
        }
        },

      responsive: false,
      maintainAspectRatio: false,
      plugins: {
        legend: { labels: { boxWidth: 20 } },
        title: {
          display: true,
          text: `ç›¸é–¢ä¿‚æ•° r = ${r.toFixed(3)}ï¼ˆå›å¸°å¼: y = ${slope.toFixed(2)}x + ${intercept.toFixed(2)}ï¼‰`,
          padding: { top: 10, bottom: 10 },
          font: { size: 18 }
        }
      },
      scales: {
        x: {
          type: "category",
          labels: categories,
          title: { display: true, text: "ãƒ¨ãƒ¼ãƒ¨ãƒ¼æ­´ï¼ˆã‚¢ãƒ³ã‚±ãƒ¼ãƒˆå›ç­”ï¼‰" }
        },
        y: {
          title: { display: true, text: "ç·åˆè©•ä¾¡ï¼ˆç‚¹ï¼‰" },
          beginAtZero: true,
          suggestedMax: 100
        }
      }
    }
  });
}

// === å¾—æ„ä¸å¾—æ„ã¨ã‚¹ã‚³ã‚¢ã®æ•£å¸ƒå›³ ===
// === å¾—æ„ä¸å¾—æ„ã¨ã‚¹ã‚³ã‚¢ã®æ•£å¸ƒå›³ï¼ˆ0ã€œ5ã‚¹ã‚±ãƒ¼ãƒ«å¯¾å¿œï¼‰ ===
function drawSkillScoreChart(preSurveys) {
  if (skillChartInstance) skillChartInstance.destroy();

  

  const categories = ["0", "1", "2", "3", "4", "5"]; // è»¸ãƒ©ãƒ™ãƒ«ç”¨

  // --- skillã‚’æ•°å€¤ã‚¹ã‚±ãƒ¼ãƒ«ã¨ã—ã¦æ‰±ã† ---
  const numericData = preSurveys
    .map(s => {
      const skillNum = parseFloat(s.skill);
      const score = parseFloat(s.total_score);
      return !isNaN(skillNum) && !isNaN(score)
        ? { x: skillNum, y: score, id: s.id } // â† idã‚’ä¿æŒï¼
        : null;
    })
    .filter(Boolean);

  if (!numericData.length) {
    console.warn("âš ï¸ æ•£å¸ƒå›³ãƒ‡ãƒ¼ã‚¿ãŒç©ºã§ã™ï¼ˆskillæœªè¨˜å…¥ã¾ãŸã¯æ•°å€¤å¤‰æ›ã‚¨ãƒ©ãƒ¼ï¼‰ã€‚");
    return;
  }

  // --- å›å¸°ç›´ç·šã‚’è¨ˆç®—ï¼ˆæœ€å°äºŒä¹—æ³•ï¼‰ ---
  const n = numericData.length;
  const meanX = numericData.reduce((a, p) => a + p.x, 0) / n;
  const meanY = numericData.reduce((a, p) => a + p.y, 0) / n;

  let num = 0, den = 0;
  numericData.forEach(p => {
    num += (p.x - meanX) * (p.y - meanY);
    den += (p.x - meanX) ** 2;
  });
  const slope = num / den;
  const intercept = meanY - slope * meanX;

  // --- ç›¸é–¢ä¿‚æ•° r ---
  const numerator = numericData.reduce((a, p) => a + (p.x - meanX) * (p.y - meanY), 0);
  const denomX = Math.sqrt(numericData.reduce((a, p) => a + (p.x - meanX) ** 2, 0));
  const denomY = Math.sqrt(numericData.reduce((a, p) => a + (p.y - meanY) ** 2, 0));
  const r = numerator / (denomX * denomY);

  console.log(`âœ… skill å›å¸°ç·š: y = ${slope.toFixed(2)}x + ${intercept.toFixed(2)}, r = ${r.toFixed(3)}`);

  // --- å›å¸°ç·šãƒ‡ãƒ¼ã‚¿ ---
  const linePoints = [
    { x: 0, y: slope * 0 + intercept },
    { x: 5, y: slope * 5 + intercept }
  ];

  // --- æç”» ---
  const ctx = document.getElementById("skillScoreChart").getContext("2d");
  skillChartInstance = new Chart(ctx, {
    type: "scatter",
    data: {
      datasets: [
        {
          label: "å¾—æ„ä¸å¾—æ„ã¨ã‚¹ã‚³ã‚¢",
          data: numericData,
          backgroundColor: "rgba(75, 192, 192, 0.7)",
          borderColor: "rgba(75, 192, 192, 1)",
          pointRadius: 7
        },
        {
          label: `å›å¸°ç·šï¼ˆr=${r.toFixed(3)}ï¼‰`,
          type: "line",
          data: linePoints,
          borderColor: "rgba(0, 0, 0, 0.8)",
          borderWidth: 2,
          fill: false,
          pointRadius: 0
        }
      ]
    },
    options: {
      onClick: (evt, elements) => {
        if (elements.length > 0) {
          const idx = elements[0].index;
          const dataset = skillChartInstance.data.datasets[elements[0].datasetIndex];
          const point = dataset.data[idx];
          const id = point.id;
          if (id) {
            // viewer.html ã«ã‚¸ãƒ£ãƒ³ãƒ—ã—ã¦ãã®å±¥æ­´ã‚’é–‹ã
            window.open(`viewer.html?id=${id}`, "_blank");
          }
        }
      },
      responsive: false,
      maintainAspectRatio: false,
      plugins: {
        legend: { labels: { boxWidth: 20 } },
        title: {
          display: true,
          text: `ç›¸é–¢ä¿‚æ•° r = ${r.toFixed(3)}ï¼ˆå›å¸°å¼: y = ${slope.toFixed(2)}x + ${intercept.toFixed(2)}ï¼‰`,
          font: { size: 18 }
        }
      },
      scales: {
        x: {
            type: "linear",
            min: -0.3,
            max: 5.3,
            ticks: {
            stepSize: 1,
            callback: (value) => {
                // æ•´æ•°ã ã‘è¡¨ç¤ºï¼ˆ0,1,2,3,4,5ï¼‰
                return Number.isInteger(value) ? value.toString() : "";
            }
            },
            title: {
            display: true,
            text: "å¾—æ„ä¸å¾—æ„ï¼ˆ0=è‹¦æ‰‹, 5=å¾—æ„ï¼‰"
            }
        },
        y: {
            title: { display: true, text: "ç·åˆè©•ä¾¡ï¼ˆç‚¹ï¼‰" },
            beginAtZero: true,
            suggestedMax: 100
        }
        }

    }
  });
}

let proSkillChartInstance = null;

function drawProDistanceSkillChart(postSurveys) {
  if (proSkillChartInstance) proSkillChartInstance.destroy();

  const numericData = postSurveys
    .map(s => {
      const skill = parseFloat(s.skill);
      const proDist = parseFloat(s.pro_distance_mean);
      return (!isNaN(skill) && !isNaN(proDist))
        ? { x: skill, y: proDist, id: s.id, name: s.name }
        : null;
    })
    .filter(Boolean);

  if (!numericData.length) {
    console.warn("âš ï¸ æœ‰åŠ¹ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“ï¼ˆskill ã¾ãŸã¯ pro_distance_mean ãŒæœªè¨˜å…¥ï¼‰");
    return;
  }

  // --- å›å¸°ç›´ç·š ---
  const n = numericData.length;
  const meanX = numericData.reduce((a, p) => a + p.x, 0) / n;
  const meanY = numericData.reduce((a, p) => a + p.y, 0) / n;

  let num = 0, den = 0;
  numericData.forEach(p => {
    num += (p.x - meanX) * (p.y - meanY);
    den += (p.x - meanX) ** 2;
  });
  const slope = num / den;
  const intercept = meanY - slope * meanX;

  // --- ç›¸é–¢ä¿‚æ•° r ---
  const numerator = numericData.reduce((a, p) => a + (p.x - meanX) * (p.y - meanY), 0);
  const denomX = Math.sqrt(numericData.reduce((a, p) => a + (p.x - meanX) ** 2, 0));
  const denomY = Math.sqrt(numericData.reduce((a, p) => a + (p.y - meanY) ** 2, 0));
  const r = numerator / (denomX * denomY);

  console.log(`âœ… ãƒ—ãƒ­è·é›¢ vs å¾—æ„åº¦: y=${slope.toFixed(2)}x+${intercept.toFixed(2)} (r=${r.toFixed(3)})`);

  // --- å›å¸°ç·šãƒ‡ãƒ¼ã‚¿ ---
  const linePoints = [
    { x: 0, y: slope * 0 + intercept },
    { x: 5, y: slope * 5 + intercept }
  ];

  // --- æç”» ---
  const ctx = document.getElementById("proDistanceSkillChart").getContext("2d");
  proSkillChartInstance = new Chart(ctx, {
    type: "scatter",
    data: {
      datasets: [
        {
          label: "ãƒ—ãƒ­è·é›¢ vs å¾—æ„åº¦",
          data: numericData,
          backgroundColor: "rgba(255, 159, 64, 0.7)",
          borderColor: "rgba(255, 159, 64, 1)",
          pointRadius: 7
        },
        {
          label: `å›å¸°ç·šï¼ˆr=${r.toFixed(3)}ï¼‰`,
          type: "line",
          data: linePoints,
          borderColor: "rgba(0,0,0,0.8)",
          borderWidth: 2,
          fill: false,
          pointRadius: 0
        }
      ]
    },
    options: {
      onClick: (evt, elements) => {
        if (elements.length > 0) {
          const idx = elements[0].index;
          const dataset = proSkillChartInstance.data.datasets[elements[0].datasetIndex];
          const point = dataset.data[idx];
          if (point.id) window.open(`viewer.html?id=${point.id}`, "_blank");
        }
      },
      responsive: false,
      plugins: {
        title: {
          display: true,
          text: `ãƒ—ãƒ­è·é›¢ã¨å¾—æ„ä¸å¾—æ„ã®é–¢ä¿‚ï¼ˆr=${r.toFixed(3)} / å›å¸°å¼: y=${slope.toFixed(2)}x+${intercept.toFixed(2)}ï¼‰`,
          font: { size: 18 }
        },
        legend: { labels: { boxWidth: 20 } }
      },
      scales: {
        x: {
          type: "linear",
          min: -0.3,
          max: 5.3,
          ticks: {
            stepSize: 1,
            callback: (v) => Number.isInteger(v) ? v.toString() : ""
          },
          title: { display: true, text: "å¾—æ„ä¸å¾—æ„ï¼ˆ0=è‹¦æ‰‹, 5=å¾—æ„ï¼‰" }
        },
        y: {
          title: { display: true, text: "ãƒ—ãƒ­è·é›¢ï¼ˆå°ã•ã„ã»ã©é¡ä¼¼ï¼‰" },
          beginAtZero: true
        }
      }
    }
  });
}

// === éæ­£è¦åŒ–è‡ªå·±è·é›¢ï¼ˆraw_self_distanceï¼‰ vs å¾—æ„åº¦ ===
let rawSelfSkillChartInstance = null;

function drawRawSelfDistanceSkillChart(postSurveys) {
  if (rawSelfSkillChartInstance) rawSelfSkillChartInstance.destroy();

  const numericData = postSurveys
    .map(s => {
      const skill = parseFloat(s.skill);
      const dist = parseFloat(s.raw_self_distance);
      return (!isNaN(skill) && !isNaN(dist))
        ? { x: skill, y: dist, id: s.id, name: s.name }
        : null;
    })
    .filter(Boolean);

  if (!numericData.length) {
    console.warn("âš ï¸ æœ‰åŠ¹ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“ï¼ˆskill ã¾ãŸã¯ raw_self_distance ãŒæœªè¨˜å…¥ï¼‰");
    return;
  }

  // --- å›å¸°ç›´ç·š ---
  const n = numericData.length;
  const meanX = numericData.reduce((a, p) => a + p.x, 0) / n;
  const meanY = numericData.reduce((a, p) => a + p.y, 0) / n;
  let num = 0, den = 0;
  numericData.forEach(p => {
    num += (p.x - meanX) * (p.y - meanY);
    den += (p.x - meanX) ** 2;
  });
  const slope = num / den;
  const intercept = meanY - slope * meanX;
  const numerator = numericData.reduce((a, p) => a + (p.x - meanX) * (p.y - meanY), 0);
  const denomX = Math.sqrt(numericData.reduce((a, p) => a + (p.x - meanX) ** 2, 0));
  const denomY = Math.sqrt(numericData.reduce((a, p) => a + (p.y - meanY) ** 2, 0));
  const r = numerator / (denomX * denomY);

  console.log(`âœ… raw_self_distance vs skill: y=${slope.toFixed(2)}x+${intercept.toFixed(2)} (r=${r.toFixed(3)})`);

  // --- æç”» ---
  const ctx = document.getElementById("rawSelfSkillChart").getContext("2d");
  rawSelfSkillChartInstance = new Chart(ctx, {
    type: "scatter",
    data: {
      datasets: [
        {
          label: "raw_self_distance vs å¾—æ„åº¦",
          data: numericData,
          backgroundColor: "rgba(153, 102, 255, 0.7)",
          borderColor: "rgba(153, 102, 255, 1)",
          pointRadius: 7
        },
        {
          label: `å›å¸°ç·šï¼ˆr=${r.toFixed(3)}ï¼‰`,
          type: "line",
          data: [
            { x: 0, y: slope * 0 + intercept },
            { x: 5, y: slope * 5 + intercept }
          ],
          borderColor: "rgba(0,0,0,0.8)",
          borderWidth: 2,
          fill: false,
          pointRadius: 0
        }
      ]
    },
    options: {
      onClick: (evt, elements) => {
        if (elements.length > 0) {
          const idx = elements[0].index;
          const dataset = rawSelfSkillChartInstance.data.datasets[elements[0].datasetIndex];
          const point = dataset.data[idx];
          if (point.id) window.open(`viewer.html?id=${point.id}`, "_blank");
        }
      },
      responsive: false,
      plugins: {
        title: {
          display: true,
          text: `éæ­£è¦åŒ–è‡ªå·±è·é›¢ã¨å¾—æ„ä¸å¾—æ„ã®é–¢ä¿‚ï¼ˆr=${r.toFixed(3)} / å›å¸°å¼: y=${slope.toFixed(2)}x+${intercept.toFixed(2)}ï¼‰`,
          font: { size: 18 }
        }
      },
      scales: {
        x: {
          type: "linear",
          min: -0.3,
          max: 5.3,
          ticks: {
            stepSize: 1,
            callback: (v) => Number.isInteger(v) ? v.toString() : ""
          },
          title: { display: true, text: "å¾—æ„ä¸å¾—æ„ï¼ˆ0=è‹¦æ‰‹, 5=å¾—æ„ï¼‰" }
        },
        y: {
          title: { display: true, text: "raw_self_distanceï¼ˆå°ã•ã„ã»ã©å®‰å®šï¼‰" },
          beginAtZero: true
        }
      }
    }
  });
}

let rawSelfMedianSkillChartInstance = null;

function drawRawSelfMedianSkillChart(postSurveys) {
  if (rawSelfMedianSkillChartInstance) rawSelfMedianSkillChartInstance.destroy();

  const numericData = postSurveys
    .map(s => {
      const skill = parseFloat(s.skill);
      const dist = parseFloat(s.raw_self_median);
      return (!isNaN(skill) && !isNaN(dist))
        ? { x: skill, y: dist, id: s.id, name: s.name }
        : null;
    })
    .filter(Boolean);

  if (!numericData.length) {
    console.warn("âš ï¸ æœ‰åŠ¹ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“ï¼ˆskill ã¾ãŸã¯ raw_self_median ãŒæœªè¨˜å…¥ï¼‰");
    return;
  }

  const n = numericData.length;
  const meanX = numericData.reduce((a, p) => a + p.x, 0) / n;
  const meanY = numericData.reduce((a, p) => a + p.y, 0) / n;
  let num = 0, den = 0;
  numericData.forEach(p => {
    num += (p.x - meanX) * (p.y - meanY);
    den += (p.x - meanX) ** 2;
  });
  const slope = num / den;
  const intercept = meanY - slope * meanX;
  const numerator = numericData.reduce((a, p) => a + (p.x - meanX) * (p.y - meanY), 0);
  const denomX = Math.sqrt(numericData.reduce((a, p) => a + (p.x - meanX) ** 2, 0));
  const denomY = Math.sqrt(numericData.reduce((a, p) => a + (p.y - meanY) ** 2, 0));
  const r = numerator / (denomX * denomY);

  console.log(`âœ… raw_self_median vs skill: y=${slope.toFixed(2)}x+${intercept.toFixed(2)} (r=${r.toFixed(3)})`);

  const ctx = document.getElementById("rawSelfMedianSkillChart").getContext("2d");
  rawSelfMedianSkillChartInstance = new Chart(ctx, {
    type: "scatter",
    data: {
      datasets: [
        {
          label: "raw_self_median vs å¾—æ„åº¦",
          data: numericData,
          backgroundColor: "rgba(100, 200, 255, 0.7)",
          borderColor: "rgba(100, 200, 255, 1)",
          pointRadius: 7
        },
        {
          label: `å›å¸°ç·šï¼ˆr=${r.toFixed(3)}ï¼‰`,
          type: "line",
          data: [
            { x: 0, y: slope * 0 + intercept },
            { x: 5, y: slope * 5 + intercept }
          ],
          borderColor: "rgba(0,0,0,0.8)",
          borderWidth: 2,
          fill: false,
          pointRadius: 0
        }
      ]
    },
    options: {
      onClick: (evt, elements) => {
        if (elements.length > 0) {
          const idx = elements[0].index;
          const dataset = rawSelfMedianSkillChartInstance.data.datasets[elements[0].datasetIndex];
          const point = dataset.data[idx];
          if (point.id) window.open(`viewer.html?id=${point.id}`, "_blank");
        }
      },
      responsive: false,
      plugins: {
        title: {
          display: true,
          text: `éæ­£è¦åŒ–è‡ªå·±è·é›¢ï¼ˆä¸­å¤®å€¤ï¼‰ã¨å¾—æ„ä¸å¾—æ„ã®é–¢ä¿‚ï¼ˆr=${r.toFixed(3)})`,
          font: { size: 18 }
        }
      },
      scales: {
        x: { type: "linear", min: -0.3, max: 5.3, ticks: { stepSize: 1 },
             title: { display: true, text: "å¾—æ„ä¸å¾—æ„ï¼ˆ0=è‹¦æ‰‹, 5=å¾—æ„ï¼‰" } },
        y: { title: { display: true, text: "raw_self_medianï¼ˆå°ã•ã„ã»ã©å®‰å®šï¼‰" },
             beginAtZero: true }
      }
    }
  });
}










    loadSurveySummary();
  </script>
</body>
</html>
