<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>アンケート集計結果</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      padding: 20px;
      text-align: center;
      overflow-x: hidden;
    }
    table {
      margin: 10px auto;
      border-collapse: collapse;
      font-size: 18px;
    }
    th, td {
      border: 1px solid #ccc;
      padding: 6px 10px;
      text-align: left;
    }
    h2 {
      margin-top: 40px;
    }
    canvas {
      margin: 30px auto;
      width: 900px;
      height: 450px;
      display: block;
      border: 1px solid #ddd;
      border-radius: 8px;
      box-shadow: 0 0 6px rgba(0,0,0,0.1);
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
  <h1>アンケート集計結果</h1>
  <a href="viewer.html" class="button">履歴一覧に戻る</a>

  <h2>年齢分布</h2>
  <canvas id="ageChart"></canvas>

  <h2>ヨーヨー歴とスコアの関係</h2>
  <canvas id="historyScoreChart"></canvas>

  <h2>得意不得意とスコアの関係</h2>
  <canvas id="skillScoreChart"></canvas>


  <div id="summary"></div>

  <script>
    let historyChartInstance = null;
    let skillChartInstance = null;

    async function loadSurveySummary() {
      const res = await fetch("https://yoyo-backend.kajilab.dev/survey_summary");
      const data = await res.json();
      console.log("🔹 survey_summary:", data);

      const container = document.getElementById("summary");
      container.innerHTML = `
        <h2>事前アンケート</h2>
        ${renderSummaryTable(data.pre)}
        <h2>事後アンケート</h2>
        ${renderSummaryTable(data.post)}
      `;

      // 年齢分布
      if (data.pre?.length) drawAgeChart(data.pre);

      // スコア付きの散布図
      if (data.pre?.length) {
    drawHistoryScoreChart(data.pre);
    drawSkillScoreChart(data.pre); // ← これ追加！
    }

    }

    function renderSummaryTable(surveys) {
      if (!surveys?.length) return "<p>データなし</p>";
      const counts = {};
      surveys.forEach(s => {
        for (const [k, v] of Object.entries(s)) {
          const val = Array.isArray(v) ? v.join(", ") : v;
          counts[k] = counts[k] || {};
          counts[k][val] = (counts[k][val] || 0) + 1;
        }
      });
      return `<table>${
        Object.entries(counts)
          .map(([q, vals]) => 
            `<tr><th>${q}</th><td>${Object.entries(vals)
              .map(([ans, num]) => `${ans}: ${num}`).join("<br>")}</td></tr>`)
          .join("")
      }</table>`;
    }

    // === 年齢分布 ===
    function drawAgeChart(preSurveys) {
      const toHalfWidth = (str) => str.replace(/[０-９]/g, s => 
        String.fromCharCode(s.charCodeAt(0) - 0xFEE0)
      );

      const ages = preSurveys
        .map(s => parseInt(toHalfWidth(String(s.age || "")).trim()))
        .filter(n => !isNaN(n) && n > 0 && n < 100);

      const bins = {
        "10歳未満": 0, "10代": 0, "20代": 0, "30代": 0,
        "40代": 0, "50代": 0, "60代": 0, "70代": 0
      };

      ages.forEach(a => {
        if (a < 10) bins["10歳未満"]++;
        else if (a < 20) bins["10代"]++;
        else if (a < 30) bins["20代"]++;
        else if (a < 40) bins["30代"]++;
        else if (a < 50) bins["40代"]++;
        else if (a < 60) bins["50代"]++;
        else if (a < 70) bins["60代"]++;
        else bins["70代"]++;
      });

      const ctx = document.getElementById("ageChart").getContext("2d");
      new Chart(ctx, {
        type: "bar",
        data: {
          labels: Object.keys(bins),
          datasets: [{
            label: "年齢分布（10歳刻み）",
            data: Object.values(bins),
            backgroundColor: "rgba(54, 162, 235, 0.6)"
          }]
        },
        options: { responsive: false, scales: { y: { beginAtZero: true } } }
      });
    }

    // === 散布図 ===
    function drawHistoryScoreChart(preSurveys) {
  if (historyChartInstance) historyChartInstance.destroy();

  // --- 全角→半角＋整形 ---
  const normalize = (str) =>
    (str || "")
      .replace(/[Ａ-Ｚａ-ｚ０-９]/g, s => String.fromCharCode(s.charCodeAt(0) - 0xFEE0))
      .replace(/[〜～]/g, "～")
      .replace(/(カ月|ヶ月)/g, "か月")
      .replace(/\s+/g, "")
      .trim();

  const categories = [
    "はじめて",
    "3か月未満",
    "3か月～半年",
    "半年～1年",
    "1～2年",
    "3～4年",
    "5年以上"
  ];

  const mapHistoryToIndex = (history) => {
    const h = normalize(history);
    return categories.findIndex(cat => h === cat);
  };

  // --- データ点を数値軸に変換 ---
  const numericData = preSurveys
    .map(s => {
      const idx = mapHistoryToIndex(s.history);
      const score = parseFloat(s.total_score);
      return idx >= 0 && !isNaN(score) ? { x: idx, y: score } : null;
    })
    .filter(Boolean);

  if (!numericData.length) {
    console.warn("⚠️ 散布図データが空です。");
    return;
  }

  // --- 回帰直線を計算（最小二乗法） ---
  const n = numericData.length;
  const meanX = numericData.reduce((a, p) => a + p.x, 0) / n;
  const meanY = numericData.reduce((a, p) => a + p.y, 0) / n;

  let num = 0, den = 0;
  numericData.forEach(p => {
    num += (p.x - meanX) * (p.y - meanY);
    den += (p.x - meanX) ** 2;
  });

  const slope = num / den; // 傾き
  const intercept = meanY - slope * meanX; // 切片

  // --- 相関係数 r ---
  const numerator = numericData.reduce((a, p) => a + (p.x - meanX) * (p.y - meanY), 0);
  const denomX = Math.sqrt(numericData.reduce((a, p) => a + (p.x - meanX) ** 2, 0));
  const denomY = Math.sqrt(numericData.reduce((a, p) => a + (p.y - meanY) ** 2, 0));
  const r = numerator / (denomX * denomY);

  console.log(`✅ 回帰線: y = ${slope.toFixed(2)}x + ${intercept.toFixed(2)}, r=${r.toFixed(3)}`);

  // --- 回帰直線データを生成 ---
  const linePoints = [
    { x: 0, y: slope * 0 + intercept },
    { x: categories.length - 1, y: slope * (categories.length - 1) + intercept }
  ];

  // --- 描画 ---
  const ctx = document.getElementById("historyScoreChart").getContext("2d");
  historyChartInstance = new Chart(ctx, {
    type: "scatter",
    data: {
      datasets: [
        {
          label: "ヨーヨー歴とスコア",
          data: numericData.map(p => ({ x: categories[p.x], y: p.y })),
          backgroundColor: "rgba(255, 99, 132, 0.7)",
          borderColor: "rgba(255, 99, 132, 1)",
          pointRadius: 7
        },
        {
          label: `回帰線（r=${r.toFixed(3)}）`,
          type: "line",
          data: linePoints.map(p => ({ x: categories[p.x], y: p.y })),
          borderColor: "rgba(0, 0, 0, 0.8)",
          borderWidth: 2,
          fill: false,
          pointRadius: 0
        }
      ]
    },
    options: {
      responsive: false,
      maintainAspectRatio: false,
      plugins: {
        legend: { labels: { boxWidth: 20 } },
        title: {
          display: true,
          text: `相関係数 r = ${r.toFixed(3)}（回帰式: y = ${slope.toFixed(2)}x + ${intercept.toFixed(2)}）`,
          padding: { top: 10, bottom: 10 },
          font: { size: 18 }
        }
      },
      scales: {
        x: {
          type: "category",
          labels: categories,
          title: { display: true, text: "ヨーヨー歴（アンケート回答）" }
        },
        y: {
          title: { display: true, text: "総合評価（点）" },
          beginAtZero: true,
          suggestedMax: 100
        }
      }
    }
  });
}

// === 得意不得意とスコアの散布図 ===
function drawSkillScoreChart(preSurveys) {
  if (skillChartInstance) skillChartInstance.destroy();

  // --- 全角→半角＋整形 ---
  const normalize = (str) =>
    (str || "")
      .replace(/[Ａ-Ｚａ-ｚ０-９]/g, s => String.fromCharCode(s.charCodeAt(0) - 0xFEE0))
      .replace(/[〜～]/g, "～")
      .replace(/\s+/g, "")
      .trim();

  const categories = [
    "スリープが得意",
    "ルーピングが得意",
    "どちらも得意",
    "どちらも苦手",
    "わからない"
  ];

  const mapSkillToIndex = (skill) => {
    const s = normalize(skill);
    return categories.findIndex(cat => s === cat);
  };

  // --- データ点を数値軸に変換 ---
  const numericData = preSurveys
    .map(s => {
      const idx = mapSkillToIndex(s.skill);
      const score = parseFloat(s.total_score);
      return idx >= 0 && !isNaN(score) ? { x: idx, y: score } : null;
    })
    .filter(Boolean);

  if (!numericData.length) {
    console.warn("⚠️ 散布図データが空です（skill未記入または形式不一致）。");
    return;
  }

  // --- 回帰直線を計算 ---
  const n = numericData.length;
  const meanX = numericData.reduce((a, p) => a + p.x, 0) / n;
  const meanY = numericData.reduce((a, p) => a + p.y, 0) / n;

  let num = 0, den = 0;
  numericData.forEach(p => {
    num += (p.x - meanX) * (p.y - meanY);
    den += (p.x - meanX) ** 2;
  });

  const slope = num / den;
  const intercept = meanY - slope * meanX;

  // --- 相関係数 r ---
  const numerator = numericData.reduce((a, p) => a + (p.x - meanX) * (p.y - meanY), 0);
  const denomX = Math.sqrt(numericData.reduce((a, p) => a + (p.x - meanX) ** 2, 0));
  const denomY = Math.sqrt(numericData.reduce((a, p) => a + (p.y - meanY) ** 2, 0));
  const r = numerator / (denomX * denomY);

  console.log(`✅ 得意不得意 回帰線: y=${slope.toFixed(2)}x+${intercept.toFixed(2)}, r=${r.toFixed(3)}`);

  const linePoints = [
    { x: 0, y: slope * 0 + intercept },
    { x: categories.length - 1, y: slope * (categories.length - 1) + intercept }
  ];

  const ctx = document.getElementById("skillScoreChart").getContext("2d");
  skillChartInstance = new Chart(ctx, {
    type: "scatter",
    data: {
      datasets: [
        {
          label: "得意不得意とスコア",
          data: numericData.map(p => ({ x: categories[p.x], y: p.y })),
          backgroundColor: "rgba(75, 192, 192, 0.7)",
          borderColor: "rgba(75, 192, 192, 1)",
          pointRadius: 7
        },
        {
          label: `回帰線（r=${r.toFixed(3)}）`,
          type: "line",
          data: linePoints.map(p => ({ x: categories[p.x], y: p.y })),
          borderColor: "rgba(0, 0, 0, 0.8)",
          borderWidth: 2,
          fill: false,
          pointRadius: 0
        }
      ]
    },
    options: {
      responsive: false,
      maintainAspectRatio: false,
      plugins: {
        legend: { labels: { boxWidth: 20 } },
        title: {
          display: true,
          text: `相関係数 r = ${r.toFixed(3)}（回帰式: y = ${slope.toFixed(2)}x + ${intercept.toFixed(2)}）`,
          font: { size: 18 }
        }
      },
      scales: {
        x: {
          type: "category",
          labels: categories,
          title: { display: true, text: "得意不得意（アンケート回答）" }
        },
        y: {
          title: { display: true, text: "総合評価（点）" },
          beginAtZero: true,
          suggestedMax: 100
        }
      }
    }
  });
}




    loadSurveySummary();
  </script>
</body>
</html>
